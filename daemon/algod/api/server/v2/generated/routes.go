// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"UAEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
