// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//hj790vc8AQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
