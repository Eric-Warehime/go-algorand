// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST(baseURL+"/v2/transactions", wrapper.RawTransaction, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET(baseURL+"/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET(baseURL+"/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9+3PbONLgv4LTfVWT5BMl57kTV01958SZGd8mmVTifdyNcxuIbElYkwAXAG1rc/nf",
	"v0IDIEESlORHnMfop8QiHo1Go7vRL3wcpaIoBQeu1Wj/40ilSygo/vcgTUXFtflvBiqVrNRM8NG+/0AY",
	"nwtZUPMroZpQsmBnwIkUFc8mJ/yEH8KccWa+75/wjGo6nVHFUjWtFMhnNKc8hclCkH3ihjykmp7w0XhU",
	"SlGC1AwQEpplEpTqQ6KXQKiDpqxmOUvJKaxG45FelTDaHyktGV+MPo1HtIiv5eTkd5ovxMnJe6KFpjnh",
	"VTEDScScvGKpFAf5QijCOAmmasZnXMMCZDNBcs70UlQ6KYFnjC8SCedUZhHQVQkpmzNQdmTsvXbWMXFj",
	"449ufOLGn8RhKkuV5CKleaI01RBfflnmZvnmX5bibiqCnYjZMqK0kJBZYJjy0OD+vhYaEBpJz4mY/RNS",
	"TSoFinwoaPk74/o9SU6qvb2HQA7K8qUZ852B4wOZC2mHM0Ab4JmGArH0HxLmo/3R/5w2dDl1RDk9aEBs",
	"BjMLdUunUtJVvXDczwQutKRJSRegosvXQEvc/SUQVRVmC2ieE+wW4oSUUiwkLQgO1SzA42N4Aywcdg2X",
	"WCEu7p3tZYZSCnR8CfgJtxDbkCXkGZmtrrdfZqhfRW6I7MrbFYwR3aVKLxNztqOrUobE/c44DkDogjKu",
	"NDlfsnRJFFtwcwjUUlRmyUDSJaSnkE3I0ZxAUerVuNVdzPHPtJISuK5ZB1MGDdmEHJs1zpnBX0q5GbAq",
	"M6ot+VO+IlpSrmiKBDFbEQVaGwDMoG/hFFbHwnaf9HjQeHSRGE4jKc8SyzcNK3Wc7dN4lEowMyWGZoYO",
	"KlJqSSUtQIPE9bSOrRuju/mE8TSvkF/QsiSLXMzc6a7JYr+mC99n+CC/MQCoGzjEMaKo0bCG3ksqI4iw",
	"xD+Agiss1Ix3LdKPLa9gPJlZyddfW837iWtCJPyrYtIvB1qrOV7W3wtDzQspzhWZUQUZMRLZgEAoz1pc",
	"rFJ0AXFmVVKpWcpKuzWbFmgBedPqYwbZJPeikk7MuwKtJ2+iINvGiVlzlFLAfDGkYo43ocqQjPZcwM9k",
	"VldpXMGE/MbzlUfYLAeihYdAOaZDJZAAVXyxDrQ4AYPkjcLhwWhjJNRsllQRCSmwM8jGwVneSgdAbawP",
	"BRKP+YQEbleG+A6VOmbmzeGMDuFfsUVif+2Of8QzQ3JgsEY1Hh6zQsOxqa4keJ7bPadjUlRKG84ruOmx",
	"f8LvmV7mn8L9mytm+Cnwqhjt/z6yfxX2H/z2PqIAGgWoim+H4KgAZZDDwi7cNvaE4kD7QQUbZOD4bT7P",
	"GQeSEFavVuNqTSelRMqQFQVixs0BRj++Rwy1mQG2HiFGxgHYpRC5HZi8FuHZ5IvLAMmB6SVIQv3YQhIu",
	"gr9hElOxrZ6DKo8oDQtnPE53qecARtFqyS8EbEnPgMwAOMFhCONjYtjcGc0Nm9PCyvB6kIC7BWrrnZbG",
	"6bQddXdInY2St1sRCpZLrcmKoqusJtSZPNBxhW4NxOtVidgWKMSXFewNroZk6TZTD4jvIVzdwYVfAwBk",
	"uVZYGqbgr4z1zW/jDa0tm/uSrGHpnqnWTCVO+0P0E92lAfw1nMzixCA6KnqHLumtVsQ2mblLZ6A/xVix",
	"OSOp4Aq4qpS5/miRinzSu50ryAE14qSlQSTmJh5V7AHZ7TvfLbi5kztsbvTsu15Fz1dEwoIpDebQ1rqY",
	"NTGMxqNakZ6tNG4a1Rqkmej/3fmv/d8Pkv9Lk3/vJU//c/r+46NPd+/1fnzw6aef/n/7p4effrr7X/8x",
	"GpAhkJRSiPnw6nQp52Z9b4WoeTR2JNixtcxbX8GZ0JDMmVQ6OaM5y6JLMI1+Vnij/Nk0jSsKrc02YgMH",
	"jPMGnPYUVknG8ipOr27ePx+aaV/XRhhVzU5hheog0HRJZlSnS9QXW9ObNmumzunGBb+0C35Jb2y9250G",
	"09RMLA25tOf4Rs5Fh/OuYwcRAowRR3/XBlG6hkGi4D+EXNMIdwyUBns4M9Nwss702DtMmR973UUpgGJY",
	"RtmRomsJbstrV8F4Bhd43WNaBay9t6KBM0DLkmUXHUOgHXXwukgvddu3wr2HBdxdN9gGDARGv94S3hm9",
	"zhsu7ZYG2q0R+oTycG2TrTBj9JUQIQFDCKdiaBGMI8qQ9hnNK9iEq2Og+Z9h9VfTFpeDMudadsMYrt2I",
	"G3D9pt7eKJ6NVHN2pJYb4JIop2UpxRnNE2ddHSJNKc4caWJzb4y9ZVYXt+Edvzh4+caB/2k8SnOgMqlV",
	"hcFVYbvym1mV0UuFHDggzryKFx6vs1tVMth8a11lqmWRPV+ChK42ariYIy57vBpre3AUnYV27mXeJe2t",
	"zjFgl7jGQQBl7R9obFfWPdB2CdAzynJvNPLQxlmCXVzjlLk0VwgHuLZrIfAQJTfKbnqnO346GurawJPC",
	"ufqMqXaoFfSCFZW5R1oHWuPSQxUSbVFIqgVdGQqyJoE+c+JVkZjjl6icpXEDI58pQxzcOo5MY4KNB5RR",
	"M2LFBvyQvGLBWKaZ2uKi2wEymCOKTLRLr8HdTOglIq3i7F8VEJYB1+aTxFPZOajmXFJnau6LU6M79Ody",
	"A1vzdDP8dXSMxnTQl3gIxHoFI3RT9cA9rK/MfqG1Ocb8ENjjL+HtDmfsicQ1nmpHH46aK86ccShCJ3H+",
	"ZwjjyaPan5jEVB6Ejhwd+svr0gI6MMdCJJwW4PsdHZrBmUrmUvwb4vc8vB6fLwGNjGhb1OFEqExh72DK",
	"mRA5UN5nMbV1x68nnH1wu4e0m9AK1fbQD1A97nzgkzpfAq/Ns5TbrX4u+JwtQufhAMEELdTUjt8QjIO5",
	"Sy9pTs9nND2NKxkGpoPG+9kyJGtBfGePe2fzNrILZyeBI7VuyxRuWQmyYFpDFrUGX1VhsNNurSo0mgFS",
	"bagTjK3zK1ciMkzFzylHuzf2s0fJ9VZgjV+m17mQygyr4jbvDFJW0DyuOWSI/eOWBMrYwsykhdkCQuca",
	"pLPi40CkFIxrS0UZU2VOV9a/3KDmaE72xt56D9rvRsbOmGKzHLDFfdtiRhVy8toQVXcxywOulwqbP9ii",
	"+bLimYRML5VFrBKkVurwelN7bmagzwE42cN295+SO+izUuwM7hosOvk82r//FI2u9o+9mADIYE6rXK/j",
	"Jhmyk785dhKnY3Ta2TEM43ajxtjLeDSXAP+GYca15jTZrtucJWzpeN3ms1RQTg1CYjAVG2CyfXE30ZDW",
	"wQvHRhkoLcWKMB2fHzQ1/ClZUrWMSyYLBklFUTBdOM+GEoWhJ89I/WHzw03wbFjZVMPlP6KDsPT+kc4l",
	"8naNpla+xVaNbtzXtIA2WseEKqIqA3PjuncMcUKO0IGLTvp8ZY96c9bMXGbpqOagJ39OSsm4xotFpefJ",
	"jyRdUklTw/4mQ+AmsyeP+iA/owqePCLAU2Hm55cD/NbxLkGBPIujXg6QvdchXF9yhwueFIajZHcdl2+f",
	"ykFPZjxazHP0brDg+qG3VcrMKMkguVUtcqMBp74W4fE1A16TFOv1XIoeL72yW6fMSsbJg1Zmh/7y9qXT",
	"MgohoW0fm/kAzpa+IkFLBmcYuBbfJDPmNfdC5lvtwnWg/7KeB69yBmqZP8uxi8ChXMmKv4V/VaAi9y33",
	"wUYToM3A6JoZdiLAM9TUJuQXjHk2ODkOlHerIbGiylG1zSFbgHTGrKrMBc3GxIxz/OLgJbGz2j4SdCU5",
	"yWBWLRaoIDT4j5hPXWgSXre3iktzEcwDMbPbj7M+iM+sWulEswKUpkXZx+5LbHHsGxjabtnPUHUIsTMh",
	"h1ZrU14nsJOQ1FyuZGG0nXo0yzfyhchwYK1pukR1qEWhlu1G7Q7O2Z2cgVRR18sb1+KvtkFwWaT+/yk5",
	"8x+RXg3cZvOQBngGckyE0VnPmQKMkoIzdxnw8akeDK+Oc9DnQp52licrzi2lRM/9QADYW/RxXgHtHjjr",
	"JPUmtihkHcRfUhgqUckUtqdJe57fYa8YUeoL3h6sYwNjCw7Z8QV34ScT8srdZ1LKBWcpzfOV55ItOvqn",
	"Qp/lNvZnN0nDKfqAdg0c/oi7Exo5XBF6DUJUHBbd+ocZoUNc3wAWfDWbaqnD/qnhQttL/AK0cpwNsjHK",
	"KZaDu4MzrkDa4CdDRCGfFLJl00cOGXUTJbU58ZJkhPHYA0rVz+bba6dyY6DiKeMoXB3aXEykvSXnimGo",
	"NydMk4UA5dZj1MFgTb+bPpPjC35kIH4/eSkWLH3HFjiGNYmbZVv/T3+oA+8Nct4X0/a5aUtsJFv9cyv0",
	"zU56UJZu0mj4Sr3DfY33gg8iOGLVT7xZNUBuPX442hpyW+vGRXlqCA3O0AkEJcrhHmGAlDEb04szmleW",
	"orAFseETMaTkjEfAeMm4t9rEBUQaFQm4MXheB/qpVFKdLrfmacdAc/T8xBia0s7sd92hOhuMKME1+jmG",
	"t/H4gr8FVeV6iHHUDYyg1pShbrQi/lAY6g6Uiec0r92gVglqK6BGq3JKVIahrHMpCkKdWhZnHIZxJwUo",
	"5V18Nbr6x6CvE9nuWlJ7ci4jiYayk2ZVtgCd0CyDiGB+hl8JfiVZhZoDXECKoTHu1BMDVMueHKU2N1Eq",
	"uKqKNXP5BtecLhUxPfo1TqB8rG4z+IQg+zWs9/DFm7cvnh8cvzi08sJc9Wx6ktG5JRSGIZq7kdJgVOdK",
	"AfkQovED9vvQWXAczIwpc30pZnkkIuuw/ghZTYgYpD1b4b+tFJCNBOT8tJeOFPJOWex4afW+PVJPOTdH",
	"L1FskWyPCRR910dHM/XVzmPT/0YPZC4WbUBu15qwlhmHexRjwy+MfHsLqhQ8lgRz4CWgdE1sXI7A7z5W",
	"vk5ZazNPlLjNtjRzus2LbFkHeN8wCvgZzQei895CKUGZHSTUqgHWwTAUo5cOhpRS7TI7NCVrOeVKD4R/",
	"WAc/frdQxI0rQ05969M3n3u9t1Nge9cBHHstQn20SB+gP/tQNFJS5rxnDbPoY9YFrfbDiLcJZ2s2uLsI",
	"FwqKg8RW8pItlvpZLtLTX4FmIN9IIeZRhUvMjVgpwChqaslKFAOlUKyWXiQ3g5GZGY0scbjJtqEKx0tw",
	"cZXuAt4fy/sJzyDVRqkP/B8SYMi4EFuNmczb4LDJ7Zs1DcgZlHq59khad2Wplx4rppu9BTJFZoCpaVKc",
	"AR8TNoFJNwYnWzR6Ww507g0LUohtMjvqiA5EYwh0jJTe2CyO4MY9zCsPQVOWK2fmpHV+Xaj4mDtc58JH",
	"zl1+HoZl1+Yon6kHyv/mczDsLDk7dcnYaEixxr9zKjPfIqrNekU5WUOyvQBec/2JAT2vZ2aNG74fshnJ",
	"a8dgizQXivFFMhSx0vZ812bjH5S17yPFnKNP38A1BymtyxKtTLlQkGjh3fbr4FiHCuvEuBISBnw4GOJp",
	"gBvM8HzbpLAWLJWCYkYndb6LcIFGtaUGOhkkmg7PuQ7Zz+13H6No4yJgG6Xd0WuyMVPUB2Aw1UNiSPVz",
	"4ljF5tjHqyjGjHOQiTfmdbNOuUFlaGAqpciq1PqMwoPRXEO2zelew0qiOmXaX2VPPcixwsHLIJL8FFZT",
	"K6LTJeVNqYn2sbZc1q4hyNzq7PaN3hni6lG+sAtY3AicX1LvHo9KIfJkwKJ01E+e7Z6BU5aeQkaM7PCu",
	"Sy4y+KF9Wswk5A4aMmqXwfly5ZNFyxI4ZHcnhBjNvSj1ynsPwvTd3uT8B71u/gucNatsPru7EkxOeNzr",
	"jpnm8pr8zQ+znqspMMzvmlPZQTZkp14MJO5Keo5Z6Wa4KK90usTW9vyOuhIQlYUipqVcMVVpq/PdvxZE",
	"SB8BGFCzW7exMJPRJxulQtrbJWpL/s7XVV5eNZfGjcweIfEdNoAX6s1Nu5obOXC+sGv6VY2UYCmDlNBa",
	"/iZV3C2w4UvBFikMfDPLVLZOjegrlcE9Sz2vry9xPPdvOZi2KDimcvdvRwqtDYx3CMecS3lG89u/4WA+",
	"6wHiA7K3wwrPPMh7DZFsUamu5tB8SbeaO6efYWr+Bm9kfwOzR1EzkRvKmVqkJzJf3gjLdtCc5GLhtXl7",
	"ySPnOKa1K91/QmYuEKqUkDLFOjGi575Sk49PPAPJ5ivnRL7QIZ1cYZ1/FfoaZOwuCKIkr5uqL1qgfGgg",
	"bI7oF2YqAyc3SuUx6uuRRQR/MR4VZiRtEBenLYOTraLVcfgKCTdseAo8XZc0PPVzrbZdHq4DhU6loL/O",
	"raV1C7cRQd2sbVuraR+5w8ZOPdvG2Bmv+GO6o7XVIgTLZREElXy4/4FImBt5oAW5dw8nuHdv7Jp+eND+",
	"bI7zvXtRNe7W7KwWR24MN2+fYlCDTSvJ9ArT0ryZhv0jmu7/C3AM/8m88bBOZHA8UotTqBMbF3XrSnku",
	"/IugOfIto3uhH0YLkU/IiwtalDk4hP70w+xP8PDHR9new/t/mv2493gvhUePn+7t0aeP6P2nD+/Dgx8f",
	"P9qD+/MnT2cPsgePHswePXj05PHT9OGj+7NHT57+6QdDrwZkC+jIB0GP/p4c5AuRHLw5So4NsA2aacn+",
	"DKvRp094R58LzE0RXNMUdwwKyvLRvv/pf/mdmKSiaIb3v45cjOVoqXWp9qfT8/PzSdhlukDDT6JFlS6n",
	"fh7MGGjJtTdHdayezdvB2CQbhsUEt3YlpnNMYMJvb1+8OyYHb47Mlzr8a7Q32ZvcN+OLEjgt2Wh/9BB/",
	"Qo6/xH2fmh1TzPz/03g0XQLN0ZRq/ihAS5b6T+qcLhYgJxg5ZH86ezD1Imf60Rm9PplRF7GEPRt1GISa",
	"9augju0VEF23NqqwVVVMuSJX47rWnLuT8gyDwawdyRyBGllHWVNX5qjxyvvsOltuYP/3nmUKs58qiRdd",
	"m6VhL4jOIeUKUTJF/ve7314TIYlTfd/Q9DQMuEKC/FcFctUQjDvHYZ68rwvmwrIKtSjbMQyNOI2oQdFy",
	"sjiz2eeAUuviDQ3b0LKCEJJGFzDyfS95+v7j4x8/jbYA5G9L4EQBZlF8oHn+gZwzrEqKFmWfh+jyTMaR",
	"GlioRo0beyZ2aLZpjEEY9dewzGndph3694ELDh+GtsEBFt0HmuemoeAQ24P3GOePlICH6MHenuccTn8L",
	"oJu6A7NtVQQf7WpDOepRPElcYaA+h7Gf3tbuVUlLe9B8mWSMHcY7kF/oxDCSRze40LYT+NrL7Q7XW/Qz",
	"mmHpSVDaLuX+N7uUI44VZgzHJ1aifRqPHn/De3NkLtec5gRbBkl0fSnyF37KxTn3LY02UxUFlSvUVYL6",
	"uGEM+qdBaTUNa/lNP7a8Vdm1ZFmvjOnR4Qbx9oMaYor96hKdUoHme10MD/0Zrh4iXDCl1d0J+SXsjYwZ",
	"kzVsKkQlOWTe2WSuyCwzLNalKvmc1ga2H1SYxxIVtoEJcCd3P6vcPWjfTlvlCWLAtEh8LUw9r/Z1BV8/",
	"0LFT6f1KldSDooRXKO30WcvNdm5odqbonWwjg93hbgB3Q+pNAG+t6bSLSX5+vmvvb4GYaMmDz8iVv3Fl",
	"7RXNDZ0Ey+0kXdiaHTsl7g+jxNURTvbBFixTtU6tw1q004++xMoNqHKuxMwWSlx40w36BiVA7nQ4xd2J",
	"rZcStrkaO3DRShvVMyx8s1PMPrdi1q8YFQOjqQP05ZQxhGHZlJS6zCsprQrQlyp99Y1qX39gZA2qWwbS",
	"zYrWFXhjT4lynPiz8czvUnlySNupTX9otckGCK9RnFrl3Fw0+bDuBNrlGNhcuUj0ucIgVjv6mCghXUxl",
	"KZmQTK/GhHGSgTl76DEUEqsMaFnx1Br67RTA8b+vDv6O8eyvDv5OfiJ741oFwyTMyPQ2YrCtA/0Cuh8Y",
	"q56tDmp1YK0u9NUoGMc1koKQ9RD1WviKbIi0gl78NISyC+tXjKlnBb0YrdVExt+OtnhdpamTzdOnIqwh",
	"wQkGP/jXg9pxmorABU11viIU5c/KJhSoataUU2urG1qUSThANBZqzYz+cZJY4uNlQ0UjNSrwEZD18B13",
	"Sk+10OHSkfAloM2KSQ8ZUQiupuXtdveb3d2+WkpKYc40wxoojTzxsqoFZPNEhQN3IAp+Qv6PqDDYxb7A",
	"BrGasDgDZgz4OZ0CGiSU5fj+XY2de/e6C793z+05U2QO58hBKceGXXTcu/cdqKwXdSlOSrjgCccHws6A",
	"BJFUO731q9ZbH+89/GZX8w7kGUuBHENRCkkly1fkL7yuM3U9tbzmORUPKn+t5T+99JtGiw7U92v5rru+",
	"aaYbzbCVjRmYEOp3HN1dedw8BGHu8lgfyNdcUGPvOsHAP+tVsfsx7jlWJjElPfDgPFsdHW6jl38jjtCt",
	"69RF5Fp8bz63BIjG07y9nXia7Zjpo71HtwdBuAuvhSY/o7nsM7P0z2o7iJNVwGwu7VFpPCYha3HZzWuZ",
	"ijmhY1evFguorkidfWj4iWWE9sWKPtcwM2zLL75i+/wWbzVH6LKL3h1f2PGFa/GFLkE1HAGz5tT0I7oK",
	"QnbQO5KY9fMduRgDf4sUhXe4CDIHnS5dNmGnCG6Erfhyl8M8Zd1DAzfs/0OgI9XWwroxWAB/yyzjINEL",
	"nV4gI8T3my/pZD6zOeaK16VM/Xsa6M5hvsR0XV3a1eBnysec+6RDs4uXgvJ5M3k/pwbRchM+wx2CL4fg",
	"HlN74RKm7fFyi/geotJ91e6EvBZNTqur5Pk9mj0+p0T+3At6LThYv7TRWC0t7lyQtbqAT/IgUnwxA+t4",
	"dK/8xlWHqX+jZa3+8KtptEGH2EYwm8m+Sen8a/Qlm5YAMWubbEzCbkbbhu+ahrYsXbsg3Re8WHwRVvkV",
	"3ja+BDO6He6Bh9SzECfx+db8BKt6WDqd1qULh5hLvHLj1oxGizrgKlpscQa54Av1dXKZdRsfx0uEAOqa",
	"lvHClX+8Y/kcC4Zw4WvzuRIyivEU7HMV/rWwginlwgIf7f14exBqVviyWzzMivzCjONzepBu0+WjCHV7",
	"bkMXLc+KVmJVLINOqaGmxssQf2sFaX3UFyz7tJnPBY7+S7I4xgMWF3qmaFkClVfnbZsjiY47Mx4dhiGu",
	"oi444RE+AIpB0SWDsP5ztKUhCHOlxdyJrIpbQOvXSi0HcPGnYj6u/dxGdov5Pjnh94ha0sf3H/zjweMn",
	"/s8Hj58MmLLMPK7ER9+Y1QxkPtthtrFofb8RW21Fukbe/m1v5eV2aDxi2UW0pGNT2Tk8F85tjHziB0VK",
	"uhqsBFtuqEwdDttUqb79umdKs1n88U5/I6mfPzriz+o7py3O5Qo67ypSD8RZBUzEEFpTmrrG+voq1Wu0",
	"wA5Zumvj7d8XmzB4K8U88mRHoHxRBVV/qXtjgtdG4F4haaPly+mCWHZ0HDiF6wfljD6tqrIUUtenW022",
	"UtNgMDIn1NIGCdcpYSnV6bIqpx/xP1if6VNTCcm+lzi17up1etg72+JGA5HtmE0FRNV69s650MWcvGKp",
	"FAdYkNZJDLVSGor+C+226z/WvcQXlS6C54xDUggeqyb2G359hR+jJW8xuHGgM4aZDvXtvqvZgr8DVnue",
	"bZjbdfH7ldyCr2WY6axWQlknc6DpA+m/OS0llZqlrKTuoZPYz9OPrT9dVIlrqZaVzsR50BcvSfbcb+N1",
	"DsrWbm82ri8XnfKvimSgDHV9e4acAA8x0q6/RupBBcWJB0tC/UFNO3PGsw6RoPaWijOQqr70Sx8AsrPv",
	"fD/2ne33PeBcldrErCp1s1rBa5GBHbd5yFAvIZofyEUGrrxiXxmo9Z34tdlLhqZd5yKT0mqx1KQqiRax",
	"K1PTMaGp5Z+JNXlteqHFtvIvEZwBobkEmq3IDIATMTOLbmQULpKa67GsSyc7rS7+0EgDVylFCkpBloQP",
	"WK8DrS5aibc0vQZPCDgCXM9ClCBzKq8IrFVv1gOqO0k7Nbh1JIjTYPpQbzf9ug3sTh5uI5VAvBRFs4so",
	"yhyc4SWCwi1xgnYB9pn3z09y1e2rSnwjOfJUjv16zAoUwpxyoSAVPFPRwXKqdLLp2GLR9mAtyqwgOCnR",
	"p2fNwAOXgpdUafdEd+vdj6A4vJliGODBl8vNyP7V8sjYqeGXXFWqeb3c3hMhi62Bw8WauV7DRT0XGuP9",
	"2PVFVAtSKdg08hCWgvHr98yDJ7V0YGrH0u39xWGRA+oukX1UtoBoELEOkHe+VYDd0Aw8AAi+eVqG1wD3",
	"fksD10yIHCi39jxRlub86aTidb8hNL2zrQ/0X5q2feJyyeHI1zMBKjQSOMjPLWYVRpAvqSIODlLQU2dH",
	"WLgc7T7M5jAm6LdL1lG+OZbvTKvwCGw4pN0La3j8W+esczg69BslukEi2LALQwuOXZG/Ct3/svps17nw",
	"GYMZ2iaCQL2adLTC6TllOpkLaSVmQucaZOR+26m2TJlWznBlLXhaOH8cwREcQ3HjuLf6mnJVLsHVguCL",
	"LJjd7+dUmKl+FnKrIO52XARlmlRcM18py5y3Wsf8+i7RO+15pz3vtOed9rzTnnfa80573mnPn1t7/lLB",
	"04nn0z5+JVZwg4y+SQ1/Z7FecxsJ1FR3STAqujnHa7M1NNAcF8RyFK6lUINp3/iIlxKVTIGkZjrGSZlT",
	"ow3BhfbFx8iMKnjyKHw8fiFp4Z7xMrzGNHj4gLz79cBHUy1d1E+77R1XtI0ovcrhrstqq99P8ultwA0G",
	"XXYb9bef1EW9WWV+znIgyuDqBbY+hDPIjSZvAzWIuYv0b0fHQPPnDjcbLketF3LMaB/GrTuZQ1tBy+C5",
	"QlwrVYRi5F3ngZs5zdXwCzd2vIKWsfJtNZ+21yZkDc9EtuqQu9m1KW5gm9CbmCrGqVxFgiV75N0jDS0M",
	"83GE1b/3fbrxyL8+0fbJbBOFxd8fVtFDuY7KoyFv9Yb1hrJhl/MOnYxiiandOK9RDeA2oQ6Gnv2ekLe2",
	"35dN9UGI3BFrOPNX43hut6yZBrY1CpVjPd9qXo5HfPT04tkf+wfr8WVlR3EXiWm0AJ443pLMRLZKWpyp",
	"LWAypqhSUMw2C5mQNeJhquWK+bJeBH0ZCXEYLG4duw3p4SJxvHWA8dpg1u3Ybo0tHNFx3gDjn5v7DnHI",
	"EATiWE/s7tytTn1JftZMs9rxtB1PC05jR9gz7uKou0xkcjWeJley4sPs7MUFpJWZNzykd9Rdw7IQoxe6",
	"ZbnPYFYtFkZh71uhsUoyjtc8YH3bXM4ud1sGdznisIPXpYWumxXfHa7POIJw4DtCkoUUVXnX1qznKzRw",
	"FiXlK+/UMDf/osotDm0lj5vloTaKOfbEtDeuDdvl3njzW2B9clK0/btFCzmnyr04CxmpOCZyxnIdLmw9",
	"2K3eibZDH1/whgO3q812mLxdb2R1bt5tuL/fZRfZWDtySpCJvuD2QLUOk8upsCd3siuf9ceQCG/s2xAD",
	"DLafH9AwhM2CQQYsCyVDp5iyFw1tfvqWnoelmW9Kadz+tr4ElIn17TVSedqokVLQLKUKjRoc9LmQp59Z",
	"l9QXRxErMoKJLwj0s+O2K4uB426lUrYTUv2tvJphOrfgX7o2RpP5dOAKMrWwsTPsfi+G3Wf+8ClCiaTn",
	"3cNpfTh4JrdgU/RcX/Aol5qW9gWiofjlMLXctrzRSIze8O2AjOD9H+tQhrwklKQ5Q3ez4ErLKtUnnKJD",
	"K1hYvxh/7aYbVqWe+yZxn2rE5emGOuFGqZqT2s0VVanmEHFg/wzgNTZVLRagdIcTzwFOuGvFOKk40zhX",
	"wVIpEpuRZMS14egT27KgKzKnOXpk/w1SkJm5RIRVqdE9pDTLcxcdYqYhYn7CqSY5GKb/ihmFzgznPQh1",
	"xJOluxoL8WTkBXBQTCVx6+wv9ivm+7rley8AOivsZ5+nd9uJvh52lg1CfnToXow4OsQi4E1cSA/2WwsW",
	"KBhPokRmJL6Lr+rSFrljdDxPQHebCBO36yfcKNNaEGT0VF+NHLpO3d5ZtKejQzWtjej4fv1a38eqFS5E",
	"Yq6MdGF+XzC9rGaTVBRTX8VwuhB1RcNpRqEQHL9lU1qyqSohnZ7d36AfXINfkQi72knu7yiJKKADc1rq",
	"jceX8bp7PyCXb+CBrq/7Va6NAae7N7B2b2DtXknavYG1293dG1i7F6J2L0T9UV+ImqzVEF2VwI1vtuie",
	"aZMSCamduWbgYbPW6y59ryTTE0KOl4b/UyMD4AwkzUlKlVWMuI17LrA2oqrSFCDbP+FJCxJbEdFMfKf5",
	"r73mnlR7ew+B7N3t9rF2i4Dz9vuiqoqf0NVEfiIno5NRbyQJhTgDV1Iam2cVhr/YXhuH/R/1uL/J3tYV",
	"dGWNK0talmDEmqrmc5Yyi/JcmMvAQnSitbnALyANcLZGG2HaPquF+MQodxcTQ10BpJjS3ZfvR8HbMZse",
	"0OlW0rrV2ovfr4K9jk/1N+zmeODasXsMcccyboNlfHGm8R29sLF7TOMrW1DoSG29lnWdwjwlpGzO0pjd",
	"yetI1pxseDOOAGklmV6hhKMl+8cpmP+/N3xcgTzzwq+S+Wh/tNS63J9O8T3LpVB6OjKiqfmmOh+NfKAL",
	"O4ITLqVkZ/gWzvtP/x0AAP//RiUcBMzuAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
