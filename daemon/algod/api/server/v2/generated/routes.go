// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a RoundDeltas object for a given round
	// (GET /v2/deltas/{round})
	GetRoundDeltas(ctx echo.Context, round uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetRoundDeltas converts echo context to params.
func (w *ServerInterfaceWrapper) GetRoundDeltas(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRoundDeltas(ctx, round)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/deltas/:round", wrapper.GetRoundDeltas, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
