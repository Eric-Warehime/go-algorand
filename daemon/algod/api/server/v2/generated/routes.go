// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a RoundDeltas object for a given round
	// (GET /v2/deltas/{round})
	GetRoundDeltas(ctx echo.Context, round uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetRoundDeltas converts echo context to params.
func (w *ServerInterfaceWrapper) GetRoundDeltas(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRoundDeltas(ctx, round)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/deltas/:round", wrapper.GetRoundDeltas, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
