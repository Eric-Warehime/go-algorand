// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
