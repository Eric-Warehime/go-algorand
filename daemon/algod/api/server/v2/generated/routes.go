// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"name":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Query argument name is required, but not found"))
	}

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET("/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET("/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"5/3H/xcAAP//nQ4RK7NNAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
