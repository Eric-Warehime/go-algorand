// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//kW6a9M1bAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
