// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"vX3//wcAAP//UIYAm/ZbAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
