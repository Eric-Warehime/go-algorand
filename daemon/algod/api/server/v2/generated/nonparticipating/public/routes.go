// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"

	"github.com/algorand/oapi-codegen/pkg/runtime"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"+A1toigBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
