// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
