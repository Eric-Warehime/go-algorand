// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
