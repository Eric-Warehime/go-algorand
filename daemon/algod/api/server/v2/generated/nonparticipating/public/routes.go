// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/3IedujMWwEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
