// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/0La8idCMAEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
