// Package private provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package private

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST(baseURL+"/v2/transactions", wrapper.RawTransaction, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET(baseURL+"/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET(baseURL+"/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
